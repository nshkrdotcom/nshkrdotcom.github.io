<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Temporal Mining Node Hardware Specification - NSHkr.com - North Shore Hackerspace</title>

    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <style>
        :root {
             
            --bg-primary: #080B12;
            --bg-secondary: #0F1520;
            --chat-bg: #0A0E17;
            --text-primary: #E2E8F0;
            --text-secondary: #A0AEC0;
            --accent-primary: #3B82F6;
            --accent-secondary: #60A5FA;
            --accent-tertiary: #93C5FD;
            --success: #059669;
            --warning: #D97706;
            --danger: #DC2626;
            --container-bg: rgba(17, 25, 40, 0.75);
            --border-color: rgba(255, 255, 255, 0.125);
            --message-bg: rgba(59, 130, 246, 0.05);
            --gradient-glow: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(96, 165, 250, 0.1));
            
             
            --font-size-xs: 0.75rem;     
            --font-size-sm: 0.875rem;    
            --font-size-base: 1rem;      
            --font-size-lg: 1.125rem;    
            --font-size-xl: 1.25rem;     
            --font-size-2xl: 1.5rem;     
            --font-size-3xl: 1.875rem;   
            
             
            --space-1: 0.25rem;    
            --space-2: 0.5rem;     
            --space-3: 0.75rem;    
            --space-4: 1rem;       
            --space-6: 1.5rem;     
            --space-8: 2rem;       
            --space-12: 3rem;      
            
             
            --breakpoint-mobile: 768px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--bg-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-size: var(--font-size-base);
            overflow-x: hidden;
            position: relative;
            width: 100%;
            -webkit-overflow-scrolling: touch;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--space-4);
            width: 100%;
            min-width: 320px;
        }
        
        @media (max-width: 768px) {
            .app-container {
                padding: var(--space-2);
            }
        }

        .chat-container {
            flex: 1;
            background: var(--chat-bg);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);

            position: relative;
            z-index: 2;
        }

        .chat-header {
            padding: var(--space-4) var(--space-6);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: var(--space-3);
            height: 60px;
        }

        .ai-status {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-size: var(--font-size-sm);
            color: var(--accent-secondary);
            font-weight: 500;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--accent-secondary);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-6);
            display: flex;
            flex-direction: column;
            gap: var(--space-6);
        }

        .chat-messages img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }

        .message {
            max-width: 85%;
            padding: var(--space-6);
            border-radius: 12px;
            background: var(--message-bg);
            border: 1px solid var(--border-color);
            font-size: var(--font-size-base);
            line-height: 1.7;
        }

        .message.system {
            align-self: flex-start;
            background: var(--gradient-glow);
        }
        
        @media (max-width: 768px) {
            .message {
                max-width: 100%;
            }
            
            .message.system {
                width: 100%;
            }
            
             
            .message.system {
                word-break: break-word;
                overflow-wrap: break-word;
            }
        }

        .message h1 {
            font-size: var(--font-size-2xl);
            font-weight: 600;
            margin-bottom: var(--space-4);
            letter-spacing: -0.02em;
            color: var(--text-primary);
        }

        .message h2 {
            font-size: var(--font-size-xl);
            font-weight: 600;
            color: var(--text-primary);
            margin: var(--space-8) 0 var(--space-4);
            letter-spacing: -0.01em;
        }

        .message p {
            color: var(--text-secondary);
            margin-bottom: var(--space-4);
            font-size: var(--font-size-base);
            line-height: 1.7;
        }
        
        .message ul {
            margin-bottom: var(--space-6);
        }

        .input-area {
            padding: var(--space-4) var(--space-6);
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
        }

        .fake-input {
            background: var(--chat-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: var(--space-4);
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
            cursor: text;
            transition: border-color 0.2s ease;
            min-height: 48px;
            display: flex;
            align-items: center;
        }

        .fake-input:hover {
            border-color: var(--accent-primary);
        }

        .mermaid {
            background: var(--bg-secondary);
            padding: var(--space-6);
            border-radius: 8px;
            margin: var(--space-6) 0;
            border: 1px solid var(--border-color);
            font-size: var(--font-size-sm);
        }

        pre {
            background: var(--bg-secondary);
            padding: var(--space-4);
            border-radius: 8px;
            overflow-x: auto;
            margin: var(--space-4) 0;
            border: 1px solid var(--border-color);
            font-size: var(--font-size-sm);
        }

        code {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-tertiary);
            font-size: var(--font-size-sm);
        }
        
         
        .header-anchor {
            opacity: 0;
            margin-left: 0.5rem;
            font-size: 0.8em;
            transition: opacity 0.2s ease;
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        h1:hover .header-anchor,
        h2:hover .header-anchor,
        h3:hover .header-anchor,
        h4:hover .header-anchor,
        h5:hover .header-anchor,
        h6:hover .header-anchor {
            opacity: 1;
        }

         
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: var(--accent-primary);
        }


        .ambient-bg {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 0;
            background: 
                radial-gradient(circle at 0% 0%, rgba(59, 130, 246, 0.15), transparent 50%),
                radial-gradient(circle at 100% 100%, rgba(96, 165, 250, 0.1), transparent 50%);
            width: 100vw;
            -webkit-transform: translate3d(0,0,0);
            transform: translate3d(0,0,0);
        }

        .ocean-animation-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100%;
            z-index: 1;   
            opacity: 0.4;   
            pointer-events: none;
            overflow: hidden;
            -webkit-transform: translate3d(0,0,0);
            transform: translate3d(0,0,0);
        }
        
        @media (max-width: 768px) {
            .ocean-animation-container {
                display: none;
            }
        }

        #oceanCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
        }

        .chat-container {
            position: relative;
            z-index: 2;   
        }
        @keyframes messageAppear {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(0.95);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .ambient-bg {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: -1;
            background: 
                radial-gradient(circle at 0% 0%, rgba(59, 130, 246, 0.15), transparent 50%),
                radial-gradient(circle at 100% 100%, rgba(96, 165, 250, 0.1), transparent 50%);
            width: 100vw;
            -webkit-transform: translate3d(0,0,0);
            transform: translate3d(0,0,0);
        }
    </style>
</head>
<body>
    <div class="ambient-bg"></div>
    <div class="app-container">
        <div class="chat-container">
            <div class="chat-header">
                <div class="ai-status">
                    <div class="status-dot"></div>
                    <span>NSHkr.com Security Engineering Chat</span>
                </div>
            </div>
            <div class="chat-messages">
                <main>
                    
<div class="message system">
    <article>
        <h1>Temporal Mining Node Hardware Specification</h1>
        <h1 id="temporal-mining-node-tmn-hardware-specification">Temporal Mining Node (TMN) Hardware Specification</h1>
<p>This document provides the detailed technical specifications for Temporal Mining Nodes, the specialized hardware components that form the foundation of the Temporal Blockchain System. These specifications are designed to ensure secure, accurate, and tamper-resistant timekeeping within a decentralized network.</p>
<h2 id="1-hardware-architecture-overview">1. Hardware Architecture Overview</h2>
<p>The Temporal Mining Node integrates multiple secure timing elements in a layered defense architecture to provide cryptographically verifiable time attestations.</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph TB
    subgraph PhysicalSecurityLayer
        TRE[Tamper-Resistant Enclosure]
        TS[Temperature Sensors]
        MS[Motion Sensors]
        PS[Pressure Sensors]
        LS[Light Sensors]
    end
    
    subgraph TimeSourceLayer
        CSAC[Chip-Scale Atomic Clock]
        TCXO[Temperature-Compensated Oscillator]
        GNSS[Secured GNSS Receiver]
    end
    
    subgraph ProcessingLayer
        STPU[Secure Time Processing Unit]
        HSM[Hardware Security Module]
        PUF[Physical Unclonable Function]
    end
    
    subgraph BlockchainInterfaceLayer
        BC[Blockchain Connectivity Module]
        TA[Time Attestation Engine]
        VM[Validation Module]
    end
    
    PhysicalSecurityLayer --&gt; TimeSourceLayer
    TimeSourceLayer --&gt; ProcessingLayer
    ProcessingLayer --&gt; BlockchainInterfaceLayer
</code></pre><h2 id="2-core-components-specifications">2. Core Components Specifications</h2>
<h3 id="21-primary-timing-elements">2.1 Primary Timing Elements</h3>
<h4 id="211-chip-scale-atomic-clock-csac">2.1.1 Chip-Scale Atomic Clock (CSAC)</h4>
<ul>
<li><strong>Type</strong>: Cesium or Rubidium vapor cell atomic oscillator</li>
<li><strong>Size</strong>: Maximum dimensions of 40mm × 35mm × 11mm</li>
<li><strong>Power Consumption</strong>: &lt; 120 mW at steady state</li>
<li><strong>Frequency Stability</strong>:
<ul>
<li>Short-term (1s): ≤ 3×10⁻¹⁰</li>
<li>Medium-term (1 day): ≤ 1×10⁻¹²</li>
<li>Long-term (1 year): ≤ 3×10⁻¹⁰</li>
</ul>
</li>
<li><strong>Aging Rate</strong>: &lt; 3×10⁻¹⁰ per month</li>
<li><strong>Temperature Sensitivity</strong>: &lt; 5×10⁻¹⁰ over operating temperature range</li>
<li><strong>Operating Temperature Range</strong>: -40°C to +85°C</li>
<li><strong>Radiation Hardening</strong>: Resistant to minimum 20 krad total ionizing dose</li>
</ul>
<h4 id="212-temperature-compensated-crystal-oscillator-tcxo">2.1.2 Temperature-Compensated Crystal Oscillator (TCXO)</h4>
<ul>
<li><strong>Type</strong>: SC-cut quartz crystal with ovenized compensation</li>
<li><strong>Frequency</strong>: 10 MHz nominal frequency</li>
<li><strong>Stability</strong>: ≤ 5×10⁻⁸ over operating temperature range</li>
<li><strong>Phase Noise</strong>: ≤ -130 dBc/Hz at 100 Hz offset</li>
<li><strong>Power Consumption</strong>: &lt; 100 mW at steady state</li>
<li><strong>Warm-up Time</strong>: &lt; 30 seconds to specified stability</li>
<li><strong>Aging</strong>: &lt; 1×10⁻⁷ per year</li>
</ul>
<h4 id="213-secured-gnss-receiver">2.1.3 Secured GNSS Receiver</h4>
<ul>
<li><strong>Supported Systems</strong>: GPS, Galileo, GLONASS, BeiDou</li>
<li><strong>Channels</strong>: Minimum 72 concurrent channels</li>
<li><strong>Anti-Spoofing Features</strong>:
<ul>
<li>Signal authentication processing</li>
<li>Jamming detection and mitigation</li>
<li>Spoofing detection algorithms</li>
<li>Multi-constellation cross-verification</li>
</ul>
</li>
<li><strong>Security Features</strong>:
<ul>
<li>Signed firmware with secure boot</li>
<li>Encrypted signal processing</li>
<li>Anomaly detection for timing signals</li>
</ul>
</li>
<li><strong>Acquisition Sensitivity</strong>: -160 dBm</li>
<li><strong>Positioning Accuracy</strong>: &lt; 2.5m CEP</li>
<li><strong>Timing Accuracy</strong>: &lt; 20 ns RMS (1-sigma) to UTC</li>
</ul>
<h3 id="22-secure-processing-elements">2.2 Secure Processing Elements</h3>
<h4 id="221-secure-time-processing-unit-stpu">2.2.1 Secure Time Processing Unit (STPU)</h4>
<ul>
<li><strong>Architecture</strong>: Custom silicon with secure execution environment</li>
<li><strong>Clock Management</strong>:
<ul>
<li>Clock synchronization circuits</li>
<li>Time anomaly detection</li>
<li>Drift compensation algorithms</li>
</ul>
</li>
<li><strong>Security Features</strong>:
<ul>
<li>Side-channel attack resistance</li>
<li>Fault injection detection</li>
<li>Runtime integrity monitoring</li>
</ul>
</li>
<li><strong>Performance</strong>:
<ul>
<li>Processing time for attestation: &lt; 10 ms</li>
<li>Verification time for external attestations: &lt; 5 ms</li>
</ul>
</li>
<li><strong>Cryptographic Capabilities</strong>:
<ul>
<li>Hardware-accelerated signature generation/verification</li>
<li>Temporal nonce generation</li>
<li>Time-bound key derivation</li>
</ul>
</li>
</ul>
<h4 id="222-hardware-security-module-hsm">2.2.2 Hardware Security Module (HSM)</h4>
<ul>
<li><strong>Security Certification</strong>: FIPS 140-3 Level 4 or equivalent</li>
<li><strong>Key Management</strong>:
<ul>
<li>Secure key generation</li>
<li>Temporal key derivation functions</li>
<li>Key usage counting and time-bound restrictions</li>
</ul>
</li>
<li><strong>Cryptographic Algorithms</strong>:
<ul>
<li>Symmetric: AES-256, ChaCha20</li>
<li>Asymmetric: RSA-4096, ECDSA (P-384, P-521)</li>
<li>Hash Functions: SHA-512, SHA3-256, SHA3-512</li>
<li>Post-Quantum: CRYSTALS-Dilithium, CRYSTALS-Kyber</li>
</ul>
</li>
<li><strong>Physical Security Features</strong>:
<ul>
<li>Active mesh with tamper detection</li>
<li>Environmental monitoring</li>
<li>Self-destruction capabilities for keys under attack</li>
</ul>
</li>
</ul>
<h4 id="223-physical-unclonable-function-puf">2.2.3 Physical Unclonable Function (PUF)</h4>
<ul>
<li><strong>Type</strong>: Silicon-based challenge-response PUF</li>
<li><strong>Entropy</strong>: Minimum 256-bit effective entropy</li>
<li><strong>Reliability</strong>: &lt; 10⁻⁶ bit error rate with error correction</li>
<li><strong>Uniqueness</strong>: Inter-device hamming distance &gt; 45%</li>
<li><strong>Challenge-Response Pairs</strong>: Capacity for &gt; 10⁶ unique pairs</li>
<li><strong>Tamper Evidence</strong>: Permanent alteration upon physical tampering attempts</li>
</ul>
<h3 id="23-physical-security-components">2.3 Physical Security Components</h3>
<h4 id="231-tamper-resistant-enclosure">2.3.1 Tamper-Resistant Enclosure</h4>
<ul>
<li><strong>Construction</strong>: Multi-layer composite with conductive mesh</li>
<li><strong>Penetration Resistance</strong>: Minimum 30 minutes against laboratory tools</li>
<li><strong>Environmental Protection</strong>: IP67 rating (dust-tight and waterproof)</li>
<li><strong>Tamper Detection</strong>:
<ul>
<li>Volumetric sensors</li>
<li>Breach detection mesh</li>
<li>Microdrilling detection</li>
</ul>
</li>
<li><strong>Response Mechanisms</strong>:
<ul>
<li>Key zeroization upon tamper detection</li>
<li>Secure audit logging of tamper attempts</li>
<li>Optional: epoxy potting for critical components</li>
</ul>
</li>
</ul>
<h4 id="232-environmental-sensors">2.3.2 Environmental Sensors</h4>
<ul>
<li><strong>Temperature Sensors</strong>: ±0.5°C accuracy across operating range</li>
<li><strong>Voltage Monitors</strong>: Detection of glitching and power manipulation</li>
<li><strong>Light Sensors</strong>: Detection of enclosure breaches</li>
<li><strong>Motion Sensors</strong>: 6-axis accelerometer/gyroscope for movement detection</li>
<li><strong>Pressure Sensors</strong>: Atmospheric pressure monitoring for altitude changes</li>
</ul>
<h2 id="3-performance-specifications">3. Performance Specifications</h2>
<h3 id="31-timing-performance">3.1 Timing Performance</h3>
<ul>
<li><strong>Time Accuracy to UTC</strong>: &lt; 50 ns (with GNSS), &lt; 1 μs (free-running)</li>
<li><strong>Holdover Performance</strong>:
<ul>
<li>1 hour: &lt; 100 ns drift</li>
<li>24 hours: &lt; 1 μs drift</li>
<li>7 days: &lt; 10 μs drift</li>
<li>30 days: &lt; 100 μs drift</li>
</ul>
</li>
<li><strong>Attack Detection Latency</strong>: &lt; 100 ms for timing attacks</li>
<li><strong>Attestation Accuracy</strong>: Uncertainty quantification &lt; 10 ns</li>
</ul>
<h3 id="32-security-performance">3.2 Security Performance</h3>
<ul>
<li><strong>Side-Channel Resistance</strong>: EAL 6+ or equivalent</li>
<li><strong>Key Protection</strong>: Hardware-enforced isolation of temporal attestation keys</li>
<li><strong>Temporal Proof Generation</strong>: &lt; 50 ms per proof</li>
<li><strong>Proof Verification</strong>: &lt; 20 ms per proof</li>
<li><strong>Attack Surface Reduction</strong>: Minimal external interfaces, fully hardened</li>
</ul>
<h3 id="33-blockchain-performance">3.3 Blockchain Performance</h3>
<ul>
<li><strong>Block Time Accuracy</strong>: ±5 ms maximum deviation from consensus time</li>
<li><strong>Validation Rate</strong>: &gt; 1000 temporal proofs per second</li>
<li><strong>Network Synchronization</strong>: Automatic re-synchronization within 60 seconds after connection</li>
<li><strong>Offline Operation</strong>: Secure operation for up to 30 days without network connectivity</li>
</ul>
<h2 id="4-interface-specifications">4. Interface Specifications</h2>
<h3 id="41-network-interfaces">4.1 Network Interfaces</h3>
<ul>
<li><strong>Primary Interface</strong>: Ethernet 1 Gbps (RJ45)</li>
<li><strong>Secondary Interface</strong>: Wi-Fi 6E (IEEE 802.11ax)</li>
<li><strong>Backup Interface</strong>: Cellular LTE/5G modem (optional)</li>
<li><strong>Air-Gap Support</strong>: USB 3.1 Type-C for offline transaction signing</li>
<li><strong>Protocol Support</strong>: TCP/IP, UDP, HTTPS, WebSockets, custom Temporal Blockchain Protocol</li>
</ul>
<h3 id="42-management-interfaces">4.2 Management Interfaces</h3>
<ul>
<li><strong>Local Console</strong>: USB Type-C with console redirection</li>
<li><strong>Web Interface</strong>: HTTPS-based management (two-factor authentication required)</li>
<li><strong>API</strong>: RESTful and gRPC interfaces for automation</li>
<li><strong>Monitoring</strong>: SNMP v3, Syslog over TLS</li>
</ul>
<h3 id="43-time-synchronization-interfaces">4.3 Time Synchronization Interfaces</h3>
<ul>
<li><strong>PTP/IEEE 1588</strong>: Precision Time Protocol support (optional)</li>
<li><strong>NTP Server</strong>: Secure NTP server functionality (optional)</li>
<li><strong>External Reference</strong>: SMA connector for external 10 MHz reference (optional)</li>
<li><strong>1PPS Output</strong>: SMA connector for 1 pulse-per-second output (optional)</li>
</ul>
<h2 id="5-environmental-specifications">5. Environmental Specifications</h2>
<ul>
<li><strong>Operating Temperature</strong>: -20°C to +60°C</li>
<li><strong>Storage Temperature</strong>: -40°C to +85°C</li>
<li><strong>Humidity</strong>: 5% to 95% (non-condensing)</li>
<li><strong>Altitude</strong>: Up to 3,000 meters</li>
<li><strong>Shock Resistance</strong>: MIL-STD-810H, Method 516.8</li>
<li><strong>Vibration Resistance</strong>: MIL-STD-810H, Method 514.8</li>
</ul>
<h2 id="6-power-specifications">6. Power Specifications</h2>
<ul>
<li><strong>Input Voltage</strong>: 100-240 VAC, 50-60 Hz or 12-48 VDC</li>
<li><strong>Power Consumption</strong>:
<ul>
<li>Idle: &lt; 15 W</li>
<li>Normal Operation: &lt; 35 W</li>
<li>Peak: &lt; 50 W</li>
</ul>
</li>
<li><strong>Battery Backup</strong>: Minimum 4 hours of operation during power failure</li>
<li><strong>Power Protection</strong>: Surge protection, EMI/RFI filtering</li>
</ul>
<h2 id="7-regulatory-compliance">7. Regulatory Compliance</h2>
<ul>
<li><strong>Electromagnetic Compatibility</strong>: FCC Part 15, CISPR 32/EN 55032</li>
<li><strong>Safety</strong>: IEC 60950-1, UL 60950-1</li>
<li><strong>Environmental</strong>: RoHS, WEEE compliant</li>
<li><strong>Cryptographic Validation</strong>: FIPS 140-3, Common Criteria EAL 4+</li>
</ul>
<h2 id="8-physical-specifications">8. Physical Specifications</h2>
<ul>
<li><strong>Form Factor</strong>: 1U rack-mountable or desktop enclosure</li>
<li><strong>Dimensions</strong>: 438mm × 330mm × 44mm (1U rack) or 250mm × 200mm × 60mm (desktop)</li>
<li><strong>Weight</strong>: &lt; 5 kg (rack) or &lt; 3 kg (desktop)</li>
<li><strong>Cooling</strong>: Passive cooling (no fans) for silent operation and reliability</li>
</ul>
<h2 id="9-reliability-specifications">9. Reliability Specifications</h2>
<ul>
<li><strong>MTBF</strong>: &gt; 100,000 hours</li>
<li><strong>Design Life</strong>: Minimum 10 years</li>
<li><strong>Warranty</strong>: 5 years standard, with extended options</li>
<li><strong>Serviceability</strong>: Tamper-evident field-replaceable modules</li>
</ul>
<h2 id="10-implementation-variants">10. Implementation Variants</h2>
<p>Three implementation variants are defined to accommodate different deployment scenarios:</p>
<h3 id="101-tmn-enterprise-edition">10.1 TMN Enterprise Edition</h3>
<ul>
<li>Full rack-mounted implementation with all features</li>
<li>Redundant power supplies and network interfaces</li>
<li>Extended environmental range</li>
<li>Suitable for data centers and high-security environments</li>
</ul>
<h3 id="102-tmn-standard-edition">10.2 TMN Standard Edition</h3>
<ul>
<li>Desktop form factor with core functionality</li>
<li>Single power supply with battery backup</li>
<li>Standard environmental range</li>
<li>Suitable for business and institutional deployments</li>
</ul>
<h3 id="103-tmn-embedded-edition">10.3 TMN Embedded Edition</h3>
<ul>
<li>Miniaturized form factor for integration</li>
<li>Reduced feature set but full security capabilities</li>
<li>Extended temperature range</li>
<li>Suitable for IoT gateways and embedded applications</li>
</ul>
<h2 id="11-security-certification-requirements">11. Security Certification Requirements</h2>
<p>All TMN implementations must undergo the following security certifications:</p>
<ol>
<li><strong>FIPS 140-3 Level 3+</strong> for cryptographic modules</li>
<li><strong>Common Criteria EAL 4+</strong> for overall security architecture</li>
<li><strong>Penetration testing</strong> by minimum three independent security firms</li>
<li><strong>Side-channel attack resistance</strong> verification</li>
<li><strong>Timing attack resistance</strong> verification</li>
</ol>
<h2 id="12-key-security-features">12. Key Security Features</h2>
<ol>
<li><strong>Secure Boot</strong>: Multi-stage signature verification for firmware integrity</li>
<li><strong>Firmware Updates</strong>: Cryptographically signed, atomic updates with rollback protection</li>
<li><strong>Remote Attestation</strong>: TPM-based remote attestation of software state</li>
<li><strong>Key Isolation</strong>: Hardware separation of blockchain keys from attestation keys</li>
<li><strong>Audit Logging</strong>: Tamper-evident logging of all security events</li>
<li><strong>Self-Tests</strong>: Continuous and startup self-tests for all security functions</li>
<li><strong>Secure Decommissioning</strong>: Secure key deletion and factory reset capabilities</li>
</ol>
<p>This hardware specification provides the foundation for the secure, accurate, and tamper-resistant timekeeping required by the Temporal Blockchain System. The multi-layered security approach, combined with high-precision timing elements, ensures the integrity of temporal attestations even in adversarial environments.</p>

    </article>
</div>

                </main>
            </div>
            <div class="input-area">
                <div class="fake-input">Type your message here... </div>
            </div>
        </div>
    </div>
    <script>
        
        document.addEventListener('DOMContentLoaded', () => {
            
            const codeBlocks = document.querySelectorAll('pre code.language-mermaid');
            codeBlocks.forEach(block => {
                const pre = block.parentElement;
                pre.classList.add('mermaid');
                pre.innerHTML = block.innerHTML;
            });

            mermaid.initialize({
                startOnLoad: true,
                theme: 'dark',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true,
                    curve: 'basis'
                }
            });
            
            
            const headings = document.querySelectorAll('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]');
            headings.forEach(heading => {
                const id = heading.getAttribute('id');
                if (id) {
                    const anchor = document.createElement('a');
                    anchor.className = 'header-anchor';
                    anchor.href = `#${id}`;
                    anchor.innerHTML = '¶';
                    anchor.setAttribute('aria-hidden', 'true');
                    heading.appendChild(anchor);
                }
            });

            
            if (debug) console.log('Starting ocean animation initialization...');
            initOceanAnimation();
        });

        var debug = false;

        function initOceanAnimation() {
            const oceanColors = {
                deep: 'rgba(3, 70, 148, 0.3)',      
                medium: 'rgba(4, 84, 181, 0.25)',   
                shallow: 'rgba(5, 108, 242, 0.2)',  
                highlight: 'rgba(5, 166, 107, 0.2)' 
            };

            const container = document.createElement('div');
            container.className = 'ocean-animation-container';
            
            const canvas = document.createElement('canvas');
            canvas.id = 'oceanCanvas';
            container.appendChild(canvas);

            const ambientBg = document.querySelector('.ambient-bg');
            if (debug) console.log('Found ambient-bg:', ambientBg);
            
            if (!ambientBg) {
                console.error('Could not find ambient-bg element');
                return;
            }
            
            ambientBg.parentNode.insertBefore(container, ambientBg.nextSibling);
            if (debug) console.log('Inserted canvas container');
            
            const ctx = canvas.getContext('2d');
            if (debug) console.log('Got canvas context:', ctx);
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                if (debug) console.log(`Canvas resized to ${canvas.width}x${canvas.height}`);
            }
            
            resizeCanvas();
            
            let waves = [];
            const numWaves = 3;
            
            function initWaves() {
                waves = [];
                for (let i = 0; i < numWaves; i++) {
                    waves.push({
                        y: canvas.height * (0.4 + i * 0.15),  
                        amplitude: 30 + i * 10,               
                        frequency: 0.008 - i * 0.002,        
                        speed: 0.005 + i * 0.002,           
                        offset: 0
                    });
                }
                if (debug) console.log('Waves initialized:', waves);
            }
            
            initWaves();
            
            let frameCount = 0;
            function animate() {
                frameCount++;
                if (frameCount % 60 === 0) {  
                    if (debug) console.log('Animation frame:', frameCount);
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                waves.forEach((wave, index) => {
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height);
                    
                    for (let x = 0; x <= canvas.width; x += 20) {
                        const y = wave.y + 
                            Math.sin(x * wave.frequency + wave.offset) * wave.amplitude;
                        ctx.lineTo(x, y);
                    }
                    
                    ctx.lineTo(canvas.width, canvas.height);
                    ctx.lineTo(0, canvas.height);
                    ctx.closePath();
                    
                    const gradient = ctx.createLinearGradient(
                        0, wave.y - wave.amplitude, 
                        0, wave.y + wave.amplitude
                    );
                    gradient.addColorStop(0, oceanColors.shallow);
                    gradient.addColorStop(0.5, oceanColors.medium);
                    gradient.addColorStop(1, oceanColors.deep);
                    
                    if (index === 0) {
                        ctx.shadowColor = oceanColors.highlight;
                        ctx.shadowBlur = 40;  
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    wave.offset += wave.speed;
                });
                
                requestAnimationFrame(animate);
            }
            
            window.addEventListener('resize', () => {
                resizeCanvas();
                initWaves();
            });
            
            if (debug) console.log('Starting animation loop');
            animate();
        }
















    
    
    const style = document.createElement('style');
    style.textContent = `
        .message.system {
            position: relative;
            width: 85%;
        }
        
        .ocean-wave-container {
            position: absolute;
            top: 0;
            right: -17.77%;
            width: 15%;
            height: 100%;
            min-height: 200px;
            overflow: hidden;
            border-radius: 12px;
            opacity: 0.9;
        }
        
        @media (max-width: 768px) {
            .message.system {
                width: 100%;
            }
            
            .ocean-wave-container {
                display: none;
            }
        }
    `;
    document.head.appendChild(style);

    class OceanWave {
    constructor(container) {
        this.container = container;
        this.initializeScene();
        this.initializeMaterials();
        this.createOceanMesh();
        this.setupEventListeners();
        
        
        this.ripples = [];
        this.isDragging = false;
        this.lastMousePos = null;
        this.lastRippleTime = 0;  
        this.rippleSpacing = 100; 

        this.animate();
    }

    initializeScene() {
        
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, this.container.clientWidth / this.container.clientHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            alpha: true,
            antialias: true,
            powerPreference: "high-performance"
        });

        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        this.renderer.setClearColor(0x000000, 0);
        this.container.appendChild(this.renderer.domElement);

        this.camera.position.set(0, 2, 4);
        this.camera.lookAt(0, 0, 0);
    }

    initializeMaterials() {
        this.geometry = new THREE.PlaneGeometry(10, 10, 128, 128);

        
        this.material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                color1: { value: new THREE.Color(0x080B12) },
                color2: { value: new THREE.Color(0x0F1520) },
                color3: { value: new THREE.Color(0x1a2942) },
                turbulenceValue: { value: 0.8 },
                frequencyValue: { value: 0.6 },
                ripplePositions: { value: new Float32Array(60) },
                rippleCount: { value: 0 }
            },
            vertexShader: `
                uniform float time;
                uniform float turbulenceValue;
                uniform float frequencyValue;
                uniform float ripplePositions[60];
                uniform int rippleCount;
                
                varying vec2 vUv;
                varying float vElevation;
                varying float vWaveHeight;
                varying vec3 vRippleColor;
                varying float vRippleIntensity;

                    // Simplex noise helper functions
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

                    vec3 i  = floor(v + dot(v, C.yyy));
                    vec3 x0 = v - i + dot(i, C.xxx);

                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min(g.xyz, l.zxy);
                    vec3 i2 = max(g.xyz, l.zxy);

                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;

                    i = mod289(i);
                    vec4 p = permute(permute(permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0));

                    float n_ = 0.142857142857;
                    vec3 ns = n_ * D.wyz - D.xzx;

                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_);

                    vec4 x = x_ * ns.x + ns.yyyy;
                    vec4 y = y_ * ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);

                    vec4 b0 = vec4(x.xy, y.xy);
                    vec4 b1 = vec4(x.zw, y.zw);

                    vec4 s0 = floor(b0) * 2.0 + 1.0;
                    vec4 s1 = floor(b1) * 2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));

                    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
                    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

                    vec3 p0 = vec3(a0.xy, h.x);
                    vec3 p1 = vec3(a0.zw, h.y);
                    vec3 p2 = vec3(a1.xy, h.z);
                    vec3 p3 = vec3(a1.zw, h.w);

                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                    p0 *= norm.x;
                    p1 *= norm.y;
                    p2 *= norm.z;
                    p3 *= norm.w;

                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                }

                float fluidNoise(vec3 p) {
                    float noise = 0.0;
                    float amp = 1.0;
                    float freq = frequencyValue;
                    
                    for(int i = 0; i < 4; i++) {
                        noise += amp * snoise(p * freq + time * 0.3);
                        p = vec3(p.y + 1.3, p.z - 2.1, p.x + 1.7);
                        amp *= 0.5;
                        freq *= 2.0;
                    }
                    
                    return noise * turbulenceValue;
                }

                float calculateRipples(vec2 pos, out vec3 rippleColor, out float rippleIntensity) {
                    float rippleEffect = 0.0;
                    vec3 totalColor = vec3(0.0);
                    float totalWeight = 0.0;
                    rippleIntensity = 0.0;
                    
                    for(int i = 0; i < 10; i++) {
                        if(i >= rippleCount) break;
                        
                        vec2 ripplePos = vec2(ripplePositions[i * 6], ripplePositions[i * 6 + 1]);
                        float age = ripplePositions[i * 6 + 2];
                        vec3 color = vec3(
                            ripplePositions[i * 6 + 3],
                            ripplePositions[i * 6 + 4],
                            ripplePositions[i * 6 + 5]
                        );
                        
                        float dist = length(pos - ripplePos);
                        
                        // Enhanced ripple wave pattern
                        float frequency = 4.0;
                        float speed = 4.0;
                        float decay = 1.5;
                        float wave = sin(dist * frequency - age * speed) * exp(-dist * decay - age * 0.75);
                        
                        // Improved ripple effect calculation
                        float rippleWeight = abs(wave) * smoothstep(2.0, 0.0, age);
                        rippleEffect += wave * 0.3;
                        
                        // Accumulate color with improved weighting
                        totalColor += color * rippleWeight;
                        totalWeight += rippleWeight;
                        rippleIntensity = max(rippleIntensity, rippleWeight);
                    }
                    
                    // Normalize the ripple color with improved blending
                    rippleColor = totalWeight > 0.0 ? totalColor / totalWeight : vec3(0.0);
                    rippleIntensity *= 0.6; // Adjust overall intensity
                    return rippleEffect;
                }

                void main() {
                    vUv = uv;
                    
                    vec3 pos3 = vec3(position.x * 2.0, position.y * 2.0, time * 0.2);
                    float noise = fluidNoise(pos3);
                    
                    float rippleIntensity;
                    vec3 rippleColor;
                    float rippleElevation = calculateRipples(position.xy, rippleColor, rippleIntensity);
                    float elevation = noise * 1.5 + rippleElevation;
                    
                    vElevation = elevation;
                    vWaveHeight = (elevation + 1.0) * 0.5;
                    vRippleColor = rippleColor;
                    vRippleIntensity = rippleIntensity;
                    
                    vec3 pos = position;
                    pos.z += elevation * 0.8;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color1;
                uniform vec3 color2;
                uniform vec3 color3;
                varying vec2 vUv;
                varying float vElevation;
                varying float vWaveHeight;
                varying vec3 vRippleColor;
                varying float vRippleIntensity;
                
                void main() {
                    float depthFactor = smoothstep(-1.0, 1.0, vElevation);
                    vec3 deepColor = mix(color1, color2, depthFactor * 0.7);
                    
                    float highlightIntensity = smoothstep(0.4, 1.0, vWaveHeight) * 0.4;
                    vec3 baseColor = mix(deepColor, color3, highlightIntensity);
                    
                    // Improved color blending for ripples
                    vec3 finalColor = mix(baseColor, vRippleColor, vRippleIntensity);
                    float alpha = mix(0.95, 0.98, vWaveHeight * 0.8);
                    
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true
        });
    }
 

    createOceanMesh() {
        
        this.ocean = new THREE.Mesh(this.geometry, this.material);
        this.ocean.rotation.x = -Math.PI / 2.5;
        this.scene.add(this.ocean);
    }

    setupEventListeners() {
        
        this.renderer.domElement.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.renderer.domElement.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.renderer.domElement.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.renderer.domElement.addEventListener('mouseleave', this.handleMouseUp.bind(this));

        
        window.addEventListener('resize', () => this.onResize());
    }

    handleMouseDown(event) {
        this.isDragging = true;
        const pos = this.getMousePosition(event);
        this.lastMousePos = pos;
        this.addRipple(pos.x, pos.y, false); 
    }

    handleMouseMove(event) {
        if (!this.isDragging) return;
        
        const pos = this.getMousePosition(event);
        if (this.lastMousePos) {
            const steps = 5;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = this.lastMousePos.x + (pos.x - this.lastMousePos.x) * t;
                const y = this.lastMousePos.y + (pos.y - this.lastMousePos.y) * t;
                this.addRipple(x, y, true); 
            }
        }
        this.lastMousePos = pos;
    }

    handleMouseUp() {
        this.isDragging = false;
        this.lastMousePos = null;
    }

    getMousePosition(event) {
        const rect = this.renderer.domElement.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        return { x, y };
    }

    addRipple(x, y, isDragging) {
        const currentTime = performance.now();
        if (currentTime - this.lastRippleTime < this.rippleSpacing) {
            return; 
        }
        this.lastRippleTime = currentTime;

        
        const color = isDragging 
            ? { r: 0.7, g: 0.2, b: 0.3 }  
            : { r: 0.3, g: 0.8, b: 0.4 };  

        this.ripples.push({
            x: x,
            y: y,
            age: 0,
            color: color,
            intensity: 1.0
        });
        
        if (this.ripples.length > 10) {
            this.ripples.shift();
        }
    }

    updateRipples() {
        this.ripples = this.ripples.filter(ripple => {
            ripple.age += 0.016;
            return ripple.age < 2.0;
        });

        const rippleData = new Float32Array(60);
        this.ripples.forEach((ripple, index) => {
            const baseIndex = index * 6;
            rippleData[baseIndex] = ripple.x;
            rippleData[baseIndex + 1] = ripple.y;
            rippleData[baseIndex + 2] = ripple.age;
            rippleData[baseIndex + 3] = ripple.color.r;
            rippleData[baseIndex + 4] = ripple.color.g;
            rippleData[baseIndex + 5] = ripple.color.b;
        });
        
        this.material.uniforms.ripplePositions.value = rippleData;
        this.material.uniforms.rippleCount.value = this.ripples.length;
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        
        
        this.material.uniforms.time.value += 0.01;
        
        
        this.updateRipples();
        
        this.renderer.render(this.scene, this.camera);
    }

    onResize() {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
    }
}


document.addEventListener('DOMContentLoaded', () => {
    const systemMessages = document.querySelectorAll('.message.system');
    systemMessages.forEach(message => {
        const container = document.createElement('div');
        container.className = 'ocean-wave-container';
        message.appendChild(container);
        new OceanWave(container);
    });
});


const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
            if (node.classList && node.classList.contains('message') && node.classList.contains('system')) {
                const container = document.createElement('div');
                container.className = 'ocean-wave-container';
                node.appendChild(container);
                new OceanWave(container);
            }
        });
    });
});

observer.observe(document.querySelector('.chat-messages'), { childList: true });



































function getPlaceholderMessage() {
    
    
    return "Share your thoughts...";
}


function appendMessage(text) {
    const messagesContainer = document.querySelector('.chat-messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message';
    messageDiv.textContent = text;
    messagesContainer.appendChild(messageDiv);
    
    
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}


function initializeChatInput() {
    const inputArea = document.querySelector('.input-area');
    const fakeInput = document.querySelector('.fake-input');
    
    
    const textarea = document.createElement('textarea');
    textarea.className = 'chat-textarea';
    textarea.placeholder = getPlaceholderMessage();
    textarea.rows = 1;
    
    
    textarea.style.cssText = `
        width: 100%;
        min-height: 48px;
        max-height: 200px;
        padding: var(--space-4);
        background: var(--chat-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        color: var(--text-primary);
        font-size: var(--font-size-base);
        font-family: inherit;
        resize: none;
        outline: none;
        transition: border-color 0.2s ease;
    `;
    
    
    fakeInput.replaceWith(textarea);
    
    
    function adjustHeight() {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
    }
    
    
    textarea.addEventListener('input', adjustHeight);
    
    textarea.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const text = textarea.value.trim();
            
            if (text) {
                appendMessage(text);
                textarea.value = '';
                adjustHeight();
                textarea.placeholder = getPlaceholderMessage();
            }
        }
    });
    
    
    textarea.addEventListener('focus', () => {
        textarea.style.borderColor = 'var(--accent-primary)';
    });
    
    textarea.addEventListener('blur', () => {
        textarea.style.borderColor = 'var(--border-color)';
    });
    
    textarea.addEventListener('mouseenter', () => {
        if (document.activeElement !== textarea) {
            textarea.style.borderColor = 'var(--accent-primary)';
        }
    });
    
    textarea.addEventListener('mouseleave', () => {
        if (document.activeElement !== textarea) {
            textarea.style.borderColor = 'var(--border-color)';
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
     initializeChatInput();
    
    
    const style = document.createElement('style');
    style.textContent = `
        .chat-textarea::-webkit-scrollbar {
            width: 6px;
        }
        
        .chat-textarea::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        
        .chat-textarea::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }
        
        .chat-textarea::-webkit-scrollbar-thumb:hover {
            background: var(--accent-primary);
        }
    `;
    document.head.appendChild(style);
    
});














































const mockResponses = [
    "Let me think about that for a moment...",
    "Interesting question! Here's what I think...",
    "Based on my understanding...",
    "That's a fascinating topic. Let me explain...",
    "I'd be happy to help with that...",
    "Let me break this down step by step...",
    "From my analysis...",
    "Here's my perspective on this...",
    "Allow me to elaborate...",
    "That's an intriguing point. Here's my response...",
    "I've processed your request. Here's what I found...",
    "Let me share my thoughts on this...",
    "After careful consideration...",
    "Here's what I've determined...",
    "I've analyzed your question and...",
    "Let me provide a detailed response...",
    "That's an excellent question. Here's my answer...",
    "I'd be glad to explain this...",
    "Here's my comprehensive response...",
    "Let me address that point by point..."
];


class MockResponseAdapter {
    constructor() {
        this.isResponding = false;
    }

    async generateResponse(userInput) {
        if (this.isResponding) return null;
        this.isResponding = true;

        try {
            
            const initialDelay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, initialDelay));

            
            const starter = mockResponses[Math.floor(Math.random() * mockResponses.length)];
            
            
            const content = this.generateMockContent(userInput);
            
            return {
                starter,
                content
            };
        } finally {
            this.isResponding = false;
        }
    }

    generateMockContent(userInput) {
        
        const words = userInput.split(' ');
        const responseLength = Math.min(words.length * 3 + 20, 100);
        const mockWords = [];
        
        for (let i = 0; i < responseLength; i++) {
            if (i < words.length) {
                mockWords.push(words[i]);
            } else {
                mockWords.push(this.getRandomWord());
            }
        }

        return mockWords.join(' ');
    }

    getRandomWord() {
        const words = [
            "specifically", "furthermore", "however", "indeed", "moreover",
            "particularly", "consequently", "therefore", "nevertheless", "essentially",
            "fundamentally", "importantly", "notably", "significantly", "ultimately"
        ];
        return words[Math.floor(Math.random() * words.length)];
    }
}


class StreamingTextHandler {
    constructor(messageElement) {
        this.messageElement = messageElement;
        this.content = '';
        this.currentIndex = 0;
        this.isStreaming = false;
    }

    async streamText(text) {
        if (this.isStreaming) return;
        this.isStreaming = true;
        this.content = text;
        this.currentIndex = 0;

        try {
            while (this.currentIndex < this.content.length) {
                
                const tokensPerChunk = Math.floor(Math.random() * 10) + 3;
                const chunk = this.content.slice(
                    this.currentIndex,
                    this.currentIndex + tokensPerChunk
                );

                this.messageElement.textContent += chunk;
                this.currentIndex += tokensPerChunk;

                
                const delay = Math.random() * 150 + 50;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            this.isStreaming = false;
        }
    }
}


class ChatManager {
    constructor() {
        this.responseAdapter = new MockResponseAdapter();
        this.messagesContainer = document.querySelector('.chat-messages');
        this.textarea = document.querySelector('.chat-textarea');
        this.isProcessing = false;
        
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        this.textarea.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter' && !e.shiftKey && !this.isProcessing) {
                e.preventDefault();
                const text = this.textarea.value.trim();
                
                if (text) {
                    this.isProcessing = true;
                    await this.handleUserMessage(text);
                    this.isProcessing = false;
                }
            }
        });
    }

    async handleUserMessage(text) {
        
        const userMessage = this.createMessageElement(text, 'user');
        this.messagesContainer.appendChild(userMessage);
        this.textarea.value = '';
        this.adjustTextareaHeight();

        
        const response = await this.responseAdapter.generateResponse(text);
        if (!response) return;

        
        const systemMessage = this.createMessageElement(response.starter, 'system');
        this.messagesContainer.appendChild(systemMessage);

        
        const streamHandler = new StreamingTextHandler(systemMessage);
        await streamHandler.streamText(response.content);

        
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }

    createMessageElement(text, type) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        messageDiv.textContent = text;
        return messageDiv;
    }

    adjustTextareaHeight() {
        this.textarea.style.height = 'auto';
        this.textarea.style.height = Math.min(this.textarea.scrollHeight, 200) + 'px';
    }
}


document.addEventListener('DOMContentLoaded', () => {
    const chatManager = new ChatManager();
});


    </script>   
</body>
</html>
