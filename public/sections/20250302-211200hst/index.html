<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Temporal Blockchain System with Integrated Hardware-Secured Timechain Technology - NSHkr.com - North Shore Hackerspace</title>

    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <style>
        :root {
             
            --bg-primary: #080B12;
            --bg-secondary: #0F1520;
            --chat-bg: #0A0E17;
            --text-primary: #E2E8F0;
            --text-secondary: #A0AEC0;
            --accent-primary: #3B82F6;
            --accent-secondary: #60A5FA;
            --accent-tertiary: #93C5FD;
            --success: #059669;
            --warning: #D97706;
            --danger: #DC2626;
            --container-bg: rgba(17, 25, 40, 0.75);
            --border-color: rgba(255, 255, 255, 0.125);
            --message-bg: rgba(59, 130, 246, 0.05);
            --gradient-glow: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(96, 165, 250, 0.1));
            
             
            --font-size-xs: 0.75rem;     
            --font-size-sm: 0.875rem;    
            --font-size-base: 1rem;      
            --font-size-lg: 1.125rem;    
            --font-size-xl: 1.25rem;     
            --font-size-2xl: 1.5rem;     
            --font-size-3xl: 1.875rem;   
            
             
            --space-1: 0.25rem;    
            --space-2: 0.5rem;     
            --space-3: 0.75rem;    
            --space-4: 1rem;       
            --space-6: 1.5rem;     
            --space-8: 2rem;       
            --space-12: 3rem;      
            
             
            --breakpoint-mobile: 768px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--bg-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-size: var(--font-size-base);
            overflow-x: hidden;
            position: relative;
            width: 100%;
            -webkit-overflow-scrolling: touch;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--space-4);
            width: 100%;
            min-width: 320px;
        }
        
        @media (max-width: 768px) {
            .app-container {
                padding: var(--space-2);
            }
        }

        .chat-container {
            flex: 1;
            background: var(--chat-bg);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);

            position: relative;
            z-index: 2;
        }

        .chat-header {
            padding: var(--space-4) var(--space-6);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: var(--space-3);
            height: 60px;
        }

        .ai-status {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-size: var(--font-size-sm);
            color: var(--accent-secondary);
            font-weight: 500;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--accent-secondary);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-6);
            display: flex;
            flex-direction: column;
            gap: var(--space-6);
        }

        .chat-messages img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }

        .message {
            max-width: 85%;
            padding: var(--space-6);
            border-radius: 12px;
            background: var(--message-bg);
            border: 1px solid var(--border-color);
            font-size: var(--font-size-base);
            line-height: 1.7;
        }

        .message.system {
            align-self: flex-start;
            background: var(--gradient-glow);
        }
        
        @media (max-width: 768px) {
            .message {
                max-width: 100%;
            }
            
            .message.system {
                width: 100%;
            }
            
             
            .message.system {
                word-break: break-word;
                overflow-wrap: break-word;
            }
        }

        .message h1 {
            font-size: var(--font-size-2xl);
            font-weight: 600;
            margin-bottom: var(--space-4);
            letter-spacing: -0.02em;
            color: var(--text-primary);
        }

        .message h2 {
            font-size: var(--font-size-xl);
            font-weight: 600;
            color: var(--text-primary);
            margin: var(--space-8) 0 var(--space-4);
            letter-spacing: -0.01em;
        }

        .message p {
            color: var(--text-secondary);
            margin-bottom: var(--space-4);
            font-size: var(--font-size-base);
            line-height: 1.7;
        }
        
        .message ul {
            margin-bottom: var(--space-6);
        }

        .input-area {
            padding: var(--space-4) var(--space-6);
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
        }

        .fake-input {
            background: var(--chat-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: var(--space-4);
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
            cursor: text;
            transition: border-color 0.2s ease;
            min-height: 48px;
            display: flex;
            align-items: center;
        }

        .fake-input:hover {
            border-color: var(--accent-primary);
        }

        .mermaid {
            background: var(--bg-secondary);
            padding: var(--space-6);
            border-radius: 8px;
            margin: var(--space-6) 0;
            border: 1px solid var(--border-color);
            font-size: var(--font-size-sm);
        }

        pre {
            background: var(--bg-secondary);
            padding: var(--space-4);
            border-radius: 8px;
            overflow-x: auto;
            margin: var(--space-4) 0;
            border: 1px solid var(--border-color);
            font-size: var(--font-size-sm);
        }

        code {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-tertiary);
            font-size: var(--font-size-sm);
        }
        
         
        .header-anchor {
            opacity: 0;
            margin-left: 0.5rem;
            font-size: 0.8em;
            transition: opacity 0.2s ease;
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        h1:hover .header-anchor,
        h2:hover .header-anchor,
        h3:hover .header-anchor,
        h4:hover .header-anchor,
        h5:hover .header-anchor,
        h6:hover .header-anchor {
            opacity: 1;
        }

         
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: var(--accent-primary);
        }


        .ambient-bg {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 0;
            background: 
                radial-gradient(circle at 0% 0%, rgba(59, 130, 246, 0.15), transparent 50%),
                radial-gradient(circle at 100% 100%, rgba(96, 165, 250, 0.1), transparent 50%);
            width: 100vw;
            -webkit-transform: translate3d(0,0,0);
            transform: translate3d(0,0,0);
        }

        .ocean-animation-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100%;
            z-index: 1;   
            opacity: 0.4;   
            pointer-events: none;
            overflow: hidden;
            -webkit-transform: translate3d(0,0,0);
            transform: translate3d(0,0,0);
        }
        
        @media (max-width: 768px) {
            .ocean-animation-container {
                display: none;
            }
        }

        #oceanCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
        }

        .chat-container {
            position: relative;
            z-index: 2;   
        }
        @keyframes messageAppear {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(0.95);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .ambient-bg {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: -1;
            background: 
                radial-gradient(circle at 0% 0%, rgba(59, 130, 246, 0.15), transparent 50%),
                radial-gradient(circle at 100% 100%, rgba(96, 165, 250, 0.1), transparent 50%);
            width: 100vw;
            -webkit-transform: translate3d(0,0,0);
            transform: translate3d(0,0,0);
        }
    </style>
</head>
<body>
    <div class="ambient-bg"></div>
    <div class="app-container">
        <div class="chat-container">
            <div class="chat-header">
                <div class="ai-status">
                    <div class="status-dot"></div>
                    <span>NSHkr.com Security Engineering Chat</span>
                </div>
            </div>
            <div class="chat-messages">
                <main>
                    
<div class="message system">
    <article>
        <h1>Temporal Blockchain System with Integrated Hardware-Secured Timechain Technology</h1>
        <h2 id="temporal-blockchain-system-with-integrated-hardware-secured-timechain-technology">Temporal Blockchain System with Integrated Hardware-Secured Timechain Technology</h2>
<h3 id="abstract">Abstract</h3>
<p>A blockchain system integrates hardware-secured timekeeping into its consensus mechanism to enable trustless temporal awareness without dependence on external oracles. This system employs specialized nodes, termed Temporal Mining Nodes (TMNs), equipped with tamper-resistant timing hardware—such as chip-scale atomic clocks (CSACs), secured GNSS receivers, and cryptographic processors—to generate and validate temporally attested blocks. A novel consensus protocol, Proof of Temporal Authority (PoTA), ensures network-wide time synchronization with Byzantine fault tolerance. Smart contracts within this system can self-trigger based on consensus-verified temporal conditions, eliminating the need for external intervention and addressing a key limitation of conventional blockchains that rely on trusted third parties for time-based operations. Additional features include mechanisms for secure offline operation, advanced clock drift compensation, a temporal reputation system, cryptographic time verification, and interoperability with existing blockchains via a temporal bridge. This invention facilitates autonomous, time-sensitive transactions while preserving decentralization and security, making it suitable for high-security environments and diverse applications.</p>
<h3 id="independent-claims">Independent Claims</h3>
<p><strong>Claim 1: A Temporal Blockchain System</strong></p>
<p>A temporal blockchain system comprising:</p>
<ul>
<li>A plurality of Temporal Mining Nodes (TMNs), each comprising:
<ul>
<li>A multi-layered hardware clock system incorporating at least one high-precision timing element, such as a chip-scale atomic clock or temperature-compensated crystal oscillator;</li>
<li>A secure time processing unit configured to cryptographically attest to temporal measurements;</li>
<li>A tamper-resistant hardware security module that safeguards private keys and performs time-related cryptographic operations;</li>
<li>At least one signal receiver for external time reference calibration, such as a secured GNSS receiver;</li>
</ul>
</li>
<li>A Proof of Temporal Authority (PoTA) consensus mechanism configured to:
<ul>
<li>Validate the temporal accuracy of proposed blocks through multi-layered verification processes;</li>
<li>Achieve network-wide time agreement with Byzantine fault tolerance;</li>
<li>Maintain a temporal reputation system for participating nodes based on historical accuracy;</li>
<li>Apply configurable penalties to nodes submitting temporally inaccurate blocks;</li>
</ul>
</li>
<li>A temporal execution engine configured to:
<ul>
<li>Enable smart contracts with native time-based self-triggering capabilities;</li>
<li>Schedule, manage, and autonomously execute functions based on the blockchain’s intrinsic time;</li>
<li>Maintain and verify temporal state across the blockchain network.</li>
</ul>
</li>
</ul>
<p><strong>Claim 2: A Method for Operating a Temporal Blockchain</strong></p>
<p>A method for operating a temporal blockchain comprising:</p>
<ul>
<li>Generating, by a hardware-secured clock system within a Temporal Mining Node (TMN), a cryptographically attested timestamp;</li>
<li>Incorporating the attested timestamp into a proposed block alongside standard blockchain data;</li>
<li>Broadcasting the proposed block to validator nodes in the network;</li>
<li>Verifying, by each validator node, the temporal accuracy of the proposed block through:
<ul>
<li>Validating the cryptographic attestation of the timestamp;</li>
<li>Comparing the block’s timestamp against the validator’s own hardware-secured clock;</li>
<li>Calculating temporal consistency with previous blocks in the chain;</li>
</ul>
</li>
<li>Achieving network-wide temporal consensus through a Byzantine fault-tolerant voting mechanism that weighs votes according to nodes’ temporal reputation;</li>
<li>Executing smart contracts with temporal conditions when the consensus-verified blockchain time matches specified trigger parameters;</li>
<li>Updating temporal reputation scores of participating nodes based on the historical accuracy of their submitted timestamps and verification activities.</li>
</ul>
<p><strong>Claim 3: A Temporal Mining Node for a Blockchain System</strong></p>
<p>A Temporal Mining Node (TMN) for a blockchain system comprising:</p>
<ul>
<li>A multi-layered clock system including:
<ul>
<li>A primary high-precision clock;</li>
<li>At least one secondary clock for redundancy;</li>
<li>A time signal verification unit;</li>
</ul>
</li>
<li>A Secure Time Processing Unit (STPU) configured to:
<ul>
<li>Generate cryptographically secured temporal attestations;</li>
<li>Verify temporal attestations from other nodes;</li>
<li>Detect and mitigate temporal manipulation attempts;</li>
</ul>
</li>
<li>A hardware security module that:
<ul>
<li>Stores cryptographic keys in tamper-resistant memory;</li>
<li>Performs time-sensitive cryptographic operations;</li>
<li>Prevents extraction or modification of temporal security parameters;</li>
</ul>
</li>
<li>A processing system configured to:
<ul>
<li>Create blocks with temporally attested timestamps;</li>
<li>Participate in the temporal consensus protocol;</li>
<li>Execute scheduled transactions according to consensus-verified time;</li>
<li>Maintain temporal synchronization with the network.</li>
</ul>
</li>
</ul>
<h3 id="dependent-claims">Dependent Claims</h3>
<p><strong>For Claim 1 (System)</strong></p>
<ul>
<li><strong>Claim 4:</strong> The system of claim 1, wherein the multi-layered hardware clock system comprises a primary chip-scale atomic clock (CSAC) and a secondary temperature-compensated crystal oscillator (TCXO), with automatic fallback mechanisms to maintain temporal accuracy during component failure.</li>
<li><strong>Claim 5:</strong> The system of claim 1, wherein the secure time processing unit employs a specialized Application-Specific Integrated Circuit (ASIC) that implements hardware-level temporal verification algorithms resistant to side-channel attacks.</li>
<li><strong>Claim 6:</strong> The system of claim 1, wherein the tamper-resistant hardware security module includes a mesh sensor network, environmental monitoring systems, and self-destruction mechanisms for cryptographic keys upon detection of unauthorized physical access.</li>
<li><strong>Claim 7:</strong> The system of claim 1, wherein the signal receiver implements a multi-constellation GNSS reception system with anti-spoofing technology to detect and reject manipulated timing signals.</li>
<li><strong>Claim 8:</strong> The system of claim 1, wherein the Proof of Temporal Authority (PoTA) consensus mechanism employs a weighted voting system that assigns voting power based on a node’s historical temporal accuracy and stake in the network.</li>
<li><strong>Claim 9:</strong> The system of claim 1, wherein the temporal execution engine implements virtual machine extensions with specialized opcodes (e.g., TIMESTAMP_NOW, SCHEDULE_CALL) for temporal operations, enabling direct access to consensus-verified time.</li>
<li><strong>Claim 10:</strong> The system of claim 1, further comprising a secure offline operational mode that enables TMNs to generate verifiable timestamps without external connectivity using pre-shared cryptographic initialization vectors and drift-compensated atomic timekeeping.</li>
<li><strong>Claim 11:</strong> The system of claim 1, further comprising a temporal bridge that enables interoperability with existing blockchain networks through a cross-chain verification protocol.</li>
<li><strong>Claim 12:</strong> The system of claim 1, further comprising a temporal anomaly detection system that identifies patterns indicative of time-based attacks and triggers automatic mitigation responses.</li>
</ul>
<p><strong>For Claim 2 (Method)</strong></p>
<ul>
<li><strong>Claim 13:</strong> The method of claim 2, further comprising synchronizing hardware clocks across the network using a gossip protocol that exchanges signed time attestations between nodes, with adjustments weighted by temporal reputation scores.</li>
<li><strong>Claim 14:</strong> The method of claim 2, wherein verifying temporal accuracy includes implementing a configurable tolerance window that adjusts based on network conditions, geographic distribution of nodes, and historical performance data.</li>
<li><strong>Claim 15:</strong> The method of claim 2, further comprising generating temporal proofs using verifiable delay functions (VDFs) that require predetermined computation time to solve but can be quickly verified by other nodes.</li>
<li><strong>Claim 16:</strong> The method of claim 2, wherein achieving network-wide temporal consensus includes identifying and quarantining nodes exhibiting suspicious temporal patterns until their accuracy is verified through additional challenges.</li>
<li><strong>Claim 17:</strong> The method of claim 2, further comprising implementing temporal fencing that restricts operations to specific time windows with cryptographic enforcement at the consensus level.</li>
<li><strong>Claim 18:</strong> The method of claim 2, further comprising applying Kalman filtering algorithms to predict and compensate for clock drift across the network, with filter parameters dynamically adjusted based on observed timing variances.</li>
<li><strong>Claim 19:</strong> The method of claim 2, further comprising executing a temporal anchor ceremony during blockchain initialization that cryptographically binds the genesis block to multiple independent time sources for future verification.</li>
</ul>
<p><strong>For Claim 3 (Temporal Mining Node)</strong></p>
<ul>
<li><strong>Claim 20:</strong> The Temporal Mining Node of claim 3, wherein the primary high-precision clock is a strontium lattice atomic clock with stability better than 10⁻¹⁵ over a 24-hour period.</li>
<li><strong>Claim 21:</strong> The Temporal Mining Node of claim 3, further comprising multiple directional antennas for time signal reception that implement spatial filtering to reduce vulnerability to jamming and spoofing attacks.</li>
<li><strong>Claim 22:</strong> The Temporal Mining Node of claim 3, wherein the Secure Time Processing Unit implements physical unclonable functions (PUFs) to uniquely identify the hardware and prevent cloning of temporal verification capabilities.</li>
<li><strong>Claim 23:</strong> The Temporal Mining Node of claim 3, further comprising a quantum-resistant encryption system for temporal attestations, ensuring security against quantum computer attacks.</li>
<li><strong>Claim 24:</strong> The Temporal Mining Node of claim 3, wherein the processing system implements a specialized temporal scheduling algorithm that optimizes execution of time-sensitive operations with sub-millisecond precision.</li>
<li><strong>Claim 25:</strong> The Temporal Mining Node of claim 3, further comprising an air-gapped synchronization capability that enables secure temporal recalibration in high-security environments through optical data transfer without electromagnetic emissions.</li>
<li><strong>Claim 26:</strong> The Temporal Mining Node of claim 3, wherein the hardware security module implements a secure boot process that verifies the integrity of all temporal components before allowing participation in consensus.</li>
<li><strong>Claim 27:</strong> The Temporal Mining Node of claim 3, further comprising a multipath temporal validation system that independently verifies time through at least three different physical mechanisms to detect sophisticated attacks targeting specific timing technologies.</li>
</ul>
<h3 id="additional-notes">Additional Notes</h3>
<p>This patent draft outlines a novel blockchain system that addresses the critical challenge of reliable timekeeping in decentralized networks. The integration of hardware-secured timekeeping with the Proof of Temporal Authority (PoTA) consensus mechanism, alongside advanced security and offline capabilities, distinguishes this invention from existing blockchain technologies. Key innovations include:</p>
<ul>
<li><strong>Trustless Temporal Awareness:</strong> Eliminates reliance on external oracles by embedding precise timekeeping into the blockchain itself.</li>
<li><strong>Self-Triggering Smart Contracts:</strong> Enables autonomous execution of time-based functions, expanding use cases in finance, supply chain, and secure operations.</li>
<li><strong>Robust Security:</strong> Incorporates tamper-resistant hardware, anomaly detection, and cryptographic attestation to prevent time manipulation.</li>
<li><strong>Interoperability:</strong> Facilitates adoption by connecting with existing blockchains via a temporal bridge.</li>
</ul>
<p>For patent filing, it is recommended to:</p>
<ul>
<li>Collaborate with a patent attorney to refine claim language and ensure compliance with legal standards.</li>
<li>Conduct a prior art search to confirm novelty and non-obviousness, particularly regarding hardware-based timekeeping and temporal consensus mechanisms.</li>
<li>Include detailed technical descriptions and diagrams in the specification to support the claims and demonstrate enablement.</li>
</ul>
<p>This system has the potential to revolutionize blockchain applications requiring precise timing, offering a scalable and secure solution for decentralized environments.</p>

    </article>
</div>

                </main>
            </div>
            <div class="input-area">
                <div class="fake-input">Type your message here... </div>
            </div>
        </div>
    </div>
    <script>
        
        document.addEventListener('DOMContentLoaded', () => {
            
            const codeBlocks = document.querySelectorAll('pre code.language-mermaid');
            codeBlocks.forEach(block => {
                const pre = block.parentElement;
                pre.classList.add('mermaid');
                pre.innerHTML = block.innerHTML;
            });

            mermaid.initialize({
                startOnLoad: true,
                theme: 'dark',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true,
                    curve: 'basis'
                }
            });
            
            
            const headings = document.querySelectorAll('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]');
            headings.forEach(heading => {
                const id = heading.getAttribute('id');
                if (id) {
                    const anchor = document.createElement('a');
                    anchor.className = 'header-anchor';
                    anchor.href = `#${id}`;
                    anchor.innerHTML = '¶';
                    anchor.setAttribute('aria-hidden', 'true');
                    heading.appendChild(anchor);
                }
            });

            
            if (debug) console.log('Starting ocean animation initialization...');
            initOceanAnimation();
        });

        var debug = false;

        function initOceanAnimation() {
            const oceanColors = {
                deep: 'rgba(3, 70, 148, 0.3)',      
                medium: 'rgba(4, 84, 181, 0.25)',   
                shallow: 'rgba(5, 108, 242, 0.2)',  
                highlight: 'rgba(5, 166, 107, 0.2)' 
            };

            const container = document.createElement('div');
            container.className = 'ocean-animation-container';
            
            const canvas = document.createElement('canvas');
            canvas.id = 'oceanCanvas';
            container.appendChild(canvas);

            const ambientBg = document.querySelector('.ambient-bg');
            if (debug) console.log('Found ambient-bg:', ambientBg);
            
            if (!ambientBg) {
                console.error('Could not find ambient-bg element');
                return;
            }
            
            ambientBg.parentNode.insertBefore(container, ambientBg.nextSibling);
            if (debug) console.log('Inserted canvas container');
            
            const ctx = canvas.getContext('2d');
            if (debug) console.log('Got canvas context:', ctx);
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                if (debug) console.log(`Canvas resized to ${canvas.width}x${canvas.height}`);
            }
            
            resizeCanvas();
            
            let waves = [];
            const numWaves = 3;
            
            function initWaves() {
                waves = [];
                for (let i = 0; i < numWaves; i++) {
                    waves.push({
                        y: canvas.height * (0.4 + i * 0.15),  
                        amplitude: 30 + i * 10,               
                        frequency: 0.008 - i * 0.002,        
                        speed: 0.005 + i * 0.002,           
                        offset: 0
                    });
                }
                if (debug) console.log('Waves initialized:', waves);
            }
            
            initWaves();
            
            let frameCount = 0;
            function animate() {
                frameCount++;
                if (frameCount % 60 === 0) {  
                    if (debug) console.log('Animation frame:', frameCount);
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                waves.forEach((wave, index) => {
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height);
                    
                    for (let x = 0; x <= canvas.width; x += 20) {
                        const y = wave.y + 
                            Math.sin(x * wave.frequency + wave.offset) * wave.amplitude;
                        ctx.lineTo(x, y);
                    }
                    
                    ctx.lineTo(canvas.width, canvas.height);
                    ctx.lineTo(0, canvas.height);
                    ctx.closePath();
                    
                    const gradient = ctx.createLinearGradient(
                        0, wave.y - wave.amplitude, 
                        0, wave.y + wave.amplitude
                    );
                    gradient.addColorStop(0, oceanColors.shallow);
                    gradient.addColorStop(0.5, oceanColors.medium);
                    gradient.addColorStop(1, oceanColors.deep);
                    
                    if (index === 0) {
                        ctx.shadowColor = oceanColors.highlight;
                        ctx.shadowBlur = 40;  
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    wave.offset += wave.speed;
                });
                
                requestAnimationFrame(animate);
            }
            
            window.addEventListener('resize', () => {
                resizeCanvas();
                initWaves();
            });
            
            if (debug) console.log('Starting animation loop');
            animate();
        }
















    
    
    const style = document.createElement('style');
    style.textContent = `
        .message.system {
            position: relative;
            width: 85%;
        }
        
        .ocean-wave-container {
            position: absolute;
            top: 0;
            right: -17.77%;
            width: 15%;
            height: 100%;
            min-height: 200px;
            overflow: hidden;
            border-radius: 12px;
            opacity: 0.9;
        }
        
        @media (max-width: 768px) {
            .message.system {
                width: 100%;
            }
            
            .ocean-wave-container {
                display: none;
            }
        }
    `;
    document.head.appendChild(style);

    class OceanWave {
    constructor(container) {
        this.container = container;
        this.initializeScene();
        this.initializeMaterials();
        this.createOceanMesh();
        this.setupEventListeners();
        
        
        this.ripples = [];
        this.isDragging = false;
        this.lastMousePos = null;
        this.lastRippleTime = 0;  
        this.rippleSpacing = 100; 

        this.animate();
    }

    initializeScene() {
        
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, this.container.clientWidth / this.container.clientHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            alpha: true,
            antialias: true,
            powerPreference: "high-performance"
        });

        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        this.renderer.setClearColor(0x000000, 0);
        this.container.appendChild(this.renderer.domElement);

        this.camera.position.set(0, 2, 4);
        this.camera.lookAt(0, 0, 0);
    }

    initializeMaterials() {
        this.geometry = new THREE.PlaneGeometry(10, 10, 128, 128);

        
        this.material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                color1: { value: new THREE.Color(0x080B12) },
                color2: { value: new THREE.Color(0x0F1520) },
                color3: { value: new THREE.Color(0x1a2942) },
                turbulenceValue: { value: 0.8 },
                frequencyValue: { value: 0.6 },
                ripplePositions: { value: new Float32Array(60) },
                rippleCount: { value: 0 }
            },
            vertexShader: `
                uniform float time;
                uniform float turbulenceValue;
                uniform float frequencyValue;
                uniform float ripplePositions[60];
                uniform int rippleCount;
                
                varying vec2 vUv;
                varying float vElevation;
                varying float vWaveHeight;
                varying vec3 vRippleColor;
                varying float vRippleIntensity;

                    // Simplex noise helper functions
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

                    vec3 i  = floor(v + dot(v, C.yyy));
                    vec3 x0 = v - i + dot(i, C.xxx);

                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min(g.xyz, l.zxy);
                    vec3 i2 = max(g.xyz, l.zxy);

                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;

                    i = mod289(i);
                    vec4 p = permute(permute(permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0));

                    float n_ = 0.142857142857;
                    vec3 ns = n_ * D.wyz - D.xzx;

                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_);

                    vec4 x = x_ * ns.x + ns.yyyy;
                    vec4 y = y_ * ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);

                    vec4 b0 = vec4(x.xy, y.xy);
                    vec4 b1 = vec4(x.zw, y.zw);

                    vec4 s0 = floor(b0) * 2.0 + 1.0;
                    vec4 s1 = floor(b1) * 2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));

                    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
                    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

                    vec3 p0 = vec3(a0.xy, h.x);
                    vec3 p1 = vec3(a0.zw, h.y);
                    vec3 p2 = vec3(a1.xy, h.z);
                    vec3 p3 = vec3(a1.zw, h.w);

                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                    p0 *= norm.x;
                    p1 *= norm.y;
                    p2 *= norm.z;
                    p3 *= norm.w;

                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                }

                float fluidNoise(vec3 p) {
                    float noise = 0.0;
                    float amp = 1.0;
                    float freq = frequencyValue;
                    
                    for(int i = 0; i < 4; i++) {
                        noise += amp * snoise(p * freq + time * 0.3);
                        p = vec3(p.y + 1.3, p.z - 2.1, p.x + 1.7);
                        amp *= 0.5;
                        freq *= 2.0;
                    }
                    
                    return noise * turbulenceValue;
                }

                float calculateRipples(vec2 pos, out vec3 rippleColor, out float rippleIntensity) {
                    float rippleEffect = 0.0;
                    vec3 totalColor = vec3(0.0);
                    float totalWeight = 0.0;
                    rippleIntensity = 0.0;
                    
                    for(int i = 0; i < 10; i++) {
                        if(i >= rippleCount) break;
                        
                        vec2 ripplePos = vec2(ripplePositions[i * 6], ripplePositions[i * 6 + 1]);
                        float age = ripplePositions[i * 6 + 2];
                        vec3 color = vec3(
                            ripplePositions[i * 6 + 3],
                            ripplePositions[i * 6 + 4],
                            ripplePositions[i * 6 + 5]
                        );
                        
                        float dist = length(pos - ripplePos);
                        
                        // Enhanced ripple wave pattern
                        float frequency = 4.0;
                        float speed = 4.0;
                        float decay = 1.5;
                        float wave = sin(dist * frequency - age * speed) * exp(-dist * decay - age * 0.75);
                        
                        // Improved ripple effect calculation
                        float rippleWeight = abs(wave) * smoothstep(2.0, 0.0, age);
                        rippleEffect += wave * 0.3;
                        
                        // Accumulate color with improved weighting
                        totalColor += color * rippleWeight;
                        totalWeight += rippleWeight;
                        rippleIntensity = max(rippleIntensity, rippleWeight);
                    }
                    
                    // Normalize the ripple color with improved blending
                    rippleColor = totalWeight > 0.0 ? totalColor / totalWeight : vec3(0.0);
                    rippleIntensity *= 0.6; // Adjust overall intensity
                    return rippleEffect;
                }

                void main() {
                    vUv = uv;
                    
                    vec3 pos3 = vec3(position.x * 2.0, position.y * 2.0, time * 0.2);
                    float noise = fluidNoise(pos3);
                    
                    float rippleIntensity;
                    vec3 rippleColor;
                    float rippleElevation = calculateRipples(position.xy, rippleColor, rippleIntensity);
                    float elevation = noise * 1.5 + rippleElevation;
                    
                    vElevation = elevation;
                    vWaveHeight = (elevation + 1.0) * 0.5;
                    vRippleColor = rippleColor;
                    vRippleIntensity = rippleIntensity;
                    
                    vec3 pos = position;
                    pos.z += elevation * 0.8;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color1;
                uniform vec3 color2;
                uniform vec3 color3;
                varying vec2 vUv;
                varying float vElevation;
                varying float vWaveHeight;
                varying vec3 vRippleColor;
                varying float vRippleIntensity;
                
                void main() {
                    float depthFactor = smoothstep(-1.0, 1.0, vElevation);
                    vec3 deepColor = mix(color1, color2, depthFactor * 0.7);
                    
                    float highlightIntensity = smoothstep(0.4, 1.0, vWaveHeight) * 0.4;
                    vec3 baseColor = mix(deepColor, color3, highlightIntensity);
                    
                    // Improved color blending for ripples
                    vec3 finalColor = mix(baseColor, vRippleColor, vRippleIntensity);
                    float alpha = mix(0.95, 0.98, vWaveHeight * 0.8);
                    
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true
        });
    }
 

    createOceanMesh() {
        
        this.ocean = new THREE.Mesh(this.geometry, this.material);
        this.ocean.rotation.x = -Math.PI / 2.5;
        this.scene.add(this.ocean);
    }

    setupEventListeners() {
        
        this.renderer.domElement.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.renderer.domElement.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.renderer.domElement.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.renderer.domElement.addEventListener('mouseleave', this.handleMouseUp.bind(this));

        
        window.addEventListener('resize', () => this.onResize());
    }

    handleMouseDown(event) {
        this.isDragging = true;
        const pos = this.getMousePosition(event);
        this.lastMousePos = pos;
        this.addRipple(pos.x, pos.y, false); 
    }

    handleMouseMove(event) {
        if (!this.isDragging) return;
        
        const pos = this.getMousePosition(event);
        if (this.lastMousePos) {
            const steps = 5;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = this.lastMousePos.x + (pos.x - this.lastMousePos.x) * t;
                const y = this.lastMousePos.y + (pos.y - this.lastMousePos.y) * t;
                this.addRipple(x, y, true); 
            }
        }
        this.lastMousePos = pos;
    }

    handleMouseUp() {
        this.isDragging = false;
        this.lastMousePos = null;
    }

    getMousePosition(event) {
        const rect = this.renderer.domElement.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        return { x, y };
    }

    addRipple(x, y, isDragging) {
        const currentTime = performance.now();
        if (currentTime - this.lastRippleTime < this.rippleSpacing) {
            return; 
        }
        this.lastRippleTime = currentTime;

        
        const color = isDragging 
            ? { r: 0.7, g: 0.2, b: 0.3 }  
            : { r: 0.3, g: 0.8, b: 0.4 };  

        this.ripples.push({
            x: x,
            y: y,
            age: 0,
            color: color,
            intensity: 1.0
        });
        
        if (this.ripples.length > 10) {
            this.ripples.shift();
        }
    }

    updateRipples() {
        this.ripples = this.ripples.filter(ripple => {
            ripple.age += 0.016;
            return ripple.age < 2.0;
        });

        const rippleData = new Float32Array(60);
        this.ripples.forEach((ripple, index) => {
            const baseIndex = index * 6;
            rippleData[baseIndex] = ripple.x;
            rippleData[baseIndex + 1] = ripple.y;
            rippleData[baseIndex + 2] = ripple.age;
            rippleData[baseIndex + 3] = ripple.color.r;
            rippleData[baseIndex + 4] = ripple.color.g;
            rippleData[baseIndex + 5] = ripple.color.b;
        });
        
        this.material.uniforms.ripplePositions.value = rippleData;
        this.material.uniforms.rippleCount.value = this.ripples.length;
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        
        
        this.material.uniforms.time.value += 0.01;
        
        
        this.updateRipples();
        
        this.renderer.render(this.scene, this.camera);
    }

    onResize() {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
    }
}


document.addEventListener('DOMContentLoaded', () => {
    const systemMessages = document.querySelectorAll('.message.system');
    systemMessages.forEach(message => {
        const container = document.createElement('div');
        container.className = 'ocean-wave-container';
        message.appendChild(container);
        new OceanWave(container);
    });
});


const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
            if (node.classList && node.classList.contains('message') && node.classList.contains('system')) {
                const container = document.createElement('div');
                container.className = 'ocean-wave-container';
                node.appendChild(container);
                new OceanWave(container);
            }
        });
    });
});

observer.observe(document.querySelector('.chat-messages'), { childList: true });



































function getPlaceholderMessage() {
    
    
    return "Share your thoughts...";
}


function appendMessage(text) {
    const messagesContainer = document.querySelector('.chat-messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message';
    messageDiv.textContent = text;
    messagesContainer.appendChild(messageDiv);
    
    
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}


function initializeChatInput() {
    const inputArea = document.querySelector('.input-area');
    const fakeInput = document.querySelector('.fake-input');
    
    
    const textarea = document.createElement('textarea');
    textarea.className = 'chat-textarea';
    textarea.placeholder = getPlaceholderMessage();
    textarea.rows = 1;
    
    
    textarea.style.cssText = `
        width: 100%;
        min-height: 48px;
        max-height: 200px;
        padding: var(--space-4);
        background: var(--chat-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        color: var(--text-primary);
        font-size: var(--font-size-base);
        font-family: inherit;
        resize: none;
        outline: none;
        transition: border-color 0.2s ease;
    `;
    
    
    fakeInput.replaceWith(textarea);
    
    
    function adjustHeight() {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
    }
    
    
    textarea.addEventListener('input', adjustHeight);
    
    textarea.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const text = textarea.value.trim();
            
            if (text) {
                appendMessage(text);
                textarea.value = '';
                adjustHeight();
                textarea.placeholder = getPlaceholderMessage();
            }
        }
    });
    
    
    textarea.addEventListener('focus', () => {
        textarea.style.borderColor = 'var(--accent-primary)';
    });
    
    textarea.addEventListener('blur', () => {
        textarea.style.borderColor = 'var(--border-color)';
    });
    
    textarea.addEventListener('mouseenter', () => {
        if (document.activeElement !== textarea) {
            textarea.style.borderColor = 'var(--accent-primary)';
        }
    });
    
    textarea.addEventListener('mouseleave', () => {
        if (document.activeElement !== textarea) {
            textarea.style.borderColor = 'var(--border-color)';
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
     initializeChatInput();
    
    
    const style = document.createElement('style');
    style.textContent = `
        .chat-textarea::-webkit-scrollbar {
            width: 6px;
        }
        
        .chat-textarea::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        
        .chat-textarea::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }
        
        .chat-textarea::-webkit-scrollbar-thumb:hover {
            background: var(--accent-primary);
        }
    `;
    document.head.appendChild(style);
    
});














































const mockResponses = [
    "Let me think about that for a moment...",
    "Interesting question! Here's what I think...",
    "Based on my understanding...",
    "That's a fascinating topic. Let me explain...",
    "I'd be happy to help with that...",
    "Let me break this down step by step...",
    "From my analysis...",
    "Here's my perspective on this...",
    "Allow me to elaborate...",
    "That's an intriguing point. Here's my response...",
    "I've processed your request. Here's what I found...",
    "Let me share my thoughts on this...",
    "After careful consideration...",
    "Here's what I've determined...",
    "I've analyzed your question and...",
    "Let me provide a detailed response...",
    "That's an excellent question. Here's my answer...",
    "I'd be glad to explain this...",
    "Here's my comprehensive response...",
    "Let me address that point by point..."
];


class MockResponseAdapter {
    constructor() {
        this.isResponding = false;
    }

    async generateResponse(userInput) {
        if (this.isResponding) return null;
        this.isResponding = true;

        try {
            
            const initialDelay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, initialDelay));

            
            const starter = mockResponses[Math.floor(Math.random() * mockResponses.length)];
            
            
            const content = this.generateMockContent(userInput);
            
            return {
                starter,
                content
            };
        } finally {
            this.isResponding = false;
        }
    }

    generateMockContent(userInput) {
        
        const words = userInput.split(' ');
        const responseLength = Math.min(words.length * 3 + 20, 100);
        const mockWords = [];
        
        for (let i = 0; i < responseLength; i++) {
            if (i < words.length) {
                mockWords.push(words[i]);
            } else {
                mockWords.push(this.getRandomWord());
            }
        }

        return mockWords.join(' ');
    }

    getRandomWord() {
        const words = [
            "specifically", "furthermore", "however", "indeed", "moreover",
            "particularly", "consequently", "therefore", "nevertheless", "essentially",
            "fundamentally", "importantly", "notably", "significantly", "ultimately"
        ];
        return words[Math.floor(Math.random() * words.length)];
    }
}


class StreamingTextHandler {
    constructor(messageElement) {
        this.messageElement = messageElement;
        this.content = '';
        this.currentIndex = 0;
        this.isStreaming = false;
    }

    async streamText(text) {
        if (this.isStreaming) return;
        this.isStreaming = true;
        this.content = text;
        this.currentIndex = 0;

        try {
            while (this.currentIndex < this.content.length) {
                
                const tokensPerChunk = Math.floor(Math.random() * 10) + 3;
                const chunk = this.content.slice(
                    this.currentIndex,
                    this.currentIndex + tokensPerChunk
                );

                this.messageElement.textContent += chunk;
                this.currentIndex += tokensPerChunk;

                
                const delay = Math.random() * 150 + 50;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            this.isStreaming = false;
        }
    }
}


class ChatManager {
    constructor() {
        this.responseAdapter = new MockResponseAdapter();
        this.messagesContainer = document.querySelector('.chat-messages');
        this.textarea = document.querySelector('.chat-textarea');
        this.isProcessing = false;
        
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        this.textarea.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter' && !e.shiftKey && !this.isProcessing) {
                e.preventDefault();
                const text = this.textarea.value.trim();
                
                if (text) {
                    this.isProcessing = true;
                    await this.handleUserMessage(text);
                    this.isProcessing = false;
                }
            }
        });
    }

    async handleUserMessage(text) {
        
        const userMessage = this.createMessageElement(text, 'user');
        this.messagesContainer.appendChild(userMessage);
        this.textarea.value = '';
        this.adjustTextareaHeight();

        
        const response = await this.responseAdapter.generateResponse(text);
        if (!response) return;

        
        const systemMessage = this.createMessageElement(response.starter, 'system');
        this.messagesContainer.appendChild(systemMessage);

        
        const streamHandler = new StreamingTextHandler(systemMessage);
        await streamHandler.streamText(response.content);

        
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }

    createMessageElement(text, type) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        messageDiv.textContent = text;
        return messageDiv;
    }

    adjustTextareaHeight() {
        this.textarea.style.height = 'auto';
        this.textarea.style.height = Math.min(this.textarea.scrollHeight, 200) + 'px';
    }
}


document.addEventListener('DOMContentLoaded', () => {
    const chatManager = new ChatManager();
});


    </script>   
</body>
</html>
